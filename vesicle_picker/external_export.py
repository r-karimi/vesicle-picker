from cryosparc.dataset import Dataset
import numpy as np
import primefac
import itertools
from vesicle_picker import helpers
import pickle


def construct_csparc_dataset(micrograph, pick_indices):

    """
    Takes a micrograph and its pick indices found by segmentation and
    postprocessing, and returns a cryosparc-compatible dataset of
    particle pick locations for combination with other micrographs'
    datasets or direct export to cryosparc.

    Arguments:
    micrographs (cryosparc Micrograph object): A single micrograph and
    associated parameters as a cryosparc object.
    pick_indices (list): A list of numpy arrays containing the 0th axis
    and 1st axis indices of particle pick locations, respectively,
    upsampled to map back onto the full-resolution micrograph.

    Outputs:
    pick_dataset (cryosparc Dataset object): A cryosparc Dataset
    containing pick locations for further manipulation in cryosparc.
    """

    # Define the number of picks explicitly
    n_picks = len(pick_indices[0])

    # Extract micrograph information
    micrograph_uid = micrograph.to_list()[0]
    micrograph_path = micrograph.to_list()[1]
    micrograph_exposure_group = micrograph.to_list()[2]
    micrograph_shape = micrograph['micrograph_blob/shape']
    micrograph_psize = micrograph.to_list()[4]

    # Initialize a Dataset to hold these particle picks
    pick_dataset = Dataset([
        ('location/micrograph_uid',
         np.repeat(micrograph_uid, n_picks).astype(np.dtype('<u8'))),
        ('location/exp_group_id',
         np.repeat(micrograph_exposure_group,
                   n_picks).astype(np.dtype('<u4'))),
        ('location/micrograph_path',
         [micrograph_path] * n_picks),
        ('location/micrograph_shape',
         [[np.uint32(micrograph_shape[0]),
           np.uint32(micrograph_shape[1])]] * n_picks),
        ('location/center_y_frac',
         pick_indices[0].astype(np.dtype('<f4'))/micrograph_shape[0]),
        ('location/center_x_frac',
         pick_indices[1].astype(np.dtype('<f4'))/micrograph_shape[1]),
        ('location/micrograph_psize_A',
         np.repeat(micrograph_psize, n_picks).astype(np.dtype('<f4')))
    ])

    # Return the dataset of picks
    return pick_dataset


def export_to_csparc(cs, pick_dataset, project_id, workspace_id):

    """
    Given a set of cryosparc parameters, takes a valid Dataset in picks_dataset
    and pushes it back to cryosparc under a job titled "Vesicle Picks."

    Arguments:
    cs (cryosparc object): A valid cryosparc session.
    pick_dataset (cryosparc Dataset object): A cryosparc Dataset containing
    pick locations for further manipulation in cryosparc.
    project_id (str): A project ID within the cryosparc session (e.g. "P12")
    workspace_id (str): A workspace ID within the project above (e.g. "W9")
    """

    # Initialize project and job
    project = cs.find_project(project_id)
    job = project.create_external_job(workspace_id, title="Vesicle Picks")

    # Tell the job what kind of output to expect
    job.add_output("particle", "vesicle_picks", slots=["location"])

    # Start the job, push the output to cryosparc, stop the job
    job.start()
    job.save_output("vesicle_picks", pick_dataset)
    job.stop()


def export_masks_to_disk(masks, filename, micrograph_uid=None,
                         compression='uint16'):

    """
    Takes (postprocessed and filtered) masks from the generate_masks module
    and saves them to disk in a space-efficient format
    using a prime number encoding algorithm.

    Arguments:
    masks (list): Masks found by segmentation of a micrograph with
    generate_masks() or filtered masks generated by apply_filters().
    filename (str): The desired filename of the exported masks on disk.
    compression (str): The data type of the saved composite mask.
    uint16 lets you safely compress about 250 masks,
    and uint32 lets you safely compress about 65,000 masks.
    """

    primes = itertools.islice(primefac.primegen(), len(masks))
    primes = [prime for prime in primes]

    # Multiply each mask by its prime key
    for mask, prime in zip(masks, primes):
        mask['prime_key'] = prime
        mask['prime_segmentation'] = (
            np.ones_like(mask['segmentation']).astype(int)
        )
        mask['prime_segmentation'][mask['segmentation']] = prime

    # Generate the composite mask to be stored
    composite_mask = (
        helpers.multiply_masks(masks, 'prime_segmentation')
        .astype(compression)
    )

    # Delete the segmentation key from each mask to be written out,
    # as well as derivatives of the segmentation key.

    keys_to_delete = ['segmentation',
                      'prime_segmentation',
                      'edge',
                      'contours']

    for mask in masks:
        for key in keys_to_delete:
            mask.pop(key, None)

    # Generate the export list
    masks_export = {'masks': masks,
                    'composite_mask': composite_mask,
                    'uid': micrograph_uid}

    # Save the masks as a pickle object
    with open(filename, 'wb') as file:
        pickle.dump(masks_export, file)
